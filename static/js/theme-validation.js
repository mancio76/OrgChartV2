/**
 * Theme Validation JavaScript
 * Provides real-time client-side validation for theme forms
 */

class ThemeValidator {
    constructor(formId) {
        this.form = document.getElementById(formId);
        this.errors = new Map();
        this.init();
    }

    init() {
        if (!this.form) {
            console.error('Theme form not found');
            return;
        }

        this.setupValidationListeners();
        this.setupColorValidation();
        this.setupRealTimeValidation();
        this.createErrorDisplay();
    }

    setupValidationListeners() {
        // Add validation listeners to all form inputs
        const inputs = this.form.querySelectorAll('input, textarea, select');
        inputs.forEach(input => {
            input.addEventListener('blur', () => this.validateField(input));
            input.addEventListener('input', () => this.clearFieldError(input.name));
        });

        // Form submission validation
        this.form.addEventListener('submit', (e) => {
            if (!this.validateForm()) {
                e.preventDefault();
                this.showValidationSummary();
            }
        });
    }

    setupColorValidation() {
        // Color input synchronization and validation
        const colorPairs = [
            ['primary_color', 'primary_color_text'],
            ['secondary_color', 'secondary_color_text'],
            ['text_color', 'text_color_text'],
            ['border_color', 'border_color_text'],
            ['hover_shadow_color', 'hover_shadow_color_text']
        ];

        colorPairs.forEach(([colorId, textId]) => {
            const colorInput = document.getElementById(colorId);
            const textInput = document.getElementById(textId);

            if (colorInput && textInput) {
                colorInput.addEventListener('input', () => {
                    textInput.value = colorInput.value;
                    this.validateColorField(textInput);
                });

                textInput.addEventListener('input', () => {
                    if (this.isValidHexColor(textInput.value)) {
                        colorInput.value = textInput.value;
                    }
                    this.validateColorField(textInput);
                });
            }
        });
    }

    setupRealTimeValidation() {
        // Real-time validation for specific fields
        const nameInput = document.getElementById('name');
        if (nameInput) {
            nameInput.addEventListener('input', () => {
                this.validateName(nameInput.value);
                this.autoGenerateCssClassSuffix(nameInput.value);
            });
        }

        const cssClassSuffixInput = document.getElementById('css_class_suffix');
        if (cssClassSuffixInput) {
            cssClassSuffixInput.addEventListener('input', () => {
                this.validateCssClassSuffix(cssClassSuffixInput.value);
                delete cssClassSuffixInput.dataset.autoGenerated;
            });
        }

        const iconClassInput = document.getElementById('icon_class');
        if (iconClassInput) {
            iconClassInput.addEventListener('input', () => {
                this.validateIconClass(iconClassInput.value);
            });
        }

        const backgroundGradientInput = document.getElementById('background_gradient');
        if (backgroundGradientInput) {
            backgroundGradientInput.addEventListener('input', () => {
                this.validateBackgroundGradient(backgroundGradientInput.value);
            });
        }
    }

    validateField(input) {
        const fieldName = input.name;
        const value = input.value.trim();

        switch (fieldName) {
            case 'name':
                return this.validateName(value);
            case 'display_label':
                return this.validateDisplayLabel(value);
            case 'css_class_suffix':
                return this.validateCssClassSuffix(value);
            case 'icon_class':
                return this.validateIconClass(value);
            case 'emoji_fallback':
                return this.validateEmoji(value);
            case 'primary_color':
            case 'secondary_color':
            case 'text_color':
            case 'border_color_text':
            case 'hover_shadow_color_text':
                return this.validateColorField(input);
            case 'border_width':
                return this.validateBorderWidth(value);
            case 'hover_shadow_intensity':
                return this.validateHoverShadowIntensity(value);
            case 'background_gradient':
                return this.validateBackgroundGradient(value);
            default:
                return true;
        }
    }

    validateName(name) {
        if (!name || name.length === 0) {
            this.setFieldError('name', 'Nome del tema è obbligatorio');
            return false;
        }

        if (name.length > 100) {
            this.setFieldError('name', 'Nome troppo lungo (massimo 100 caratteri)');
            return false;
        }

        if (!/^[a-zA-Z0-9\s\-_àáâãäåæçèéêëìíîïðñòóôõöøùúûüýþÿ]+$/.test(name)) {
            this.setFieldError('name', 'Nome contiene caratteri non validi');
            return false;
        }

        this.clearFieldError('name');
        return true;
    }

    validateDisplayLabel(label) {
        if (!label || label.length === 0) {
            this.setFieldError('display_label', 'Etichetta di visualizzazione è obbligatoria');
            return false;
        }

        if (label.length > 50) {
            this.setFieldError('display_label', 'Etichetta troppo lunga (massimo 50 caratteri)');
            return false;
        }

        this.clearFieldError('display_label');
        return true;
    }

    validateCssClassSuffix(suffix) {
        if (!suffix || suffix.length === 0) {
            this.setFieldError('css_class_suffix', 'Suffisso classe CSS è obbligatorio');
            return false;
        }

        if (suffix.length > 30) {
            this.setFieldError('css_class_suffix', 'Suffisso troppo lungo (massimo 30 caratteri)');
            return false;
        }

        if (!/^[a-z][a-z0-9-_]*$/.test(suffix)) {
            this.setFieldError('css_class_suffix', 'Suffisso deve iniziare con una lettera e contenere solo lettere minuscole, numeri, trattini e underscore');
            return false;
        }

        if (suffix.startsWith('-') || suffix.endsWith('-')) {
            this.setFieldError('css_class_suffix', 'Suffisso non può iniziare o finire con un trattino');
            return false;
        }

        if (suffix.includes('--')) {
            this.setFieldError('css_class_suffix', 'Suffisso non può contenere trattini consecutivi');
            return false;
        }

        this.clearFieldError('css_class_suffix');
        return true;
    }

    validateIconClass(iconClass) {
        if (!iconClass || iconClass.length === 0) {
            this.setFieldError('icon_class', 'Classe icona è obbligatoria');
            return false;
        }

        if (iconClass.length < 2 || iconClass.length > 50) {
            this.setFieldError('icon_class', 'Classe icona deve essere tra 2 e 50 caratteri');
            return false;
        }

        if (!/^[a-z][a-z0-9-]*$/.test(iconClass)) {
            this.setFieldError('icon_class', 'Classe icona deve iniziare con una lettera e contenere solo lettere minuscole, numeri e trattini');
            return false;
        }

        if (iconClass.startsWith('-') || iconClass.endsWith('-')) {
            this.setFieldError('icon_class', 'Classe icona non può iniziare o finire con un trattino');
            return false;
        }

        if (iconClass.includes('--')) {
            this.setFieldError('icon_class', 'Classe icona non può contenere trattini consecutivi');
            return false;
        }

        this.clearFieldError('icon_class');
        return true;
    }

    validateEmoji(emoji) {
        if (!emoji || emoji.length === 0) {
            this.setFieldError('emoji_fallback', 'Emoji fallback è obbligatorio');
            return false;
        }

        if (emoji.length > 10) {
            this.setFieldError('emoji_fallback', 'Emoji troppo lungo');
            return false;
        }

        // Basic emoji validation - check if it contains emoji-like characters
        const emojiRegex = /[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]|[\u{1F900}-\u{1F9FF}]/u;
        
        if (!emojiRegex.test(emoji)) {
            this.setFieldError('emoji_fallback', 'Valore non sembra essere un emoji valido');
            return false;
        }

        this.clearFieldError('emoji_fallback');
        return true;
    }

    validateColorField(input) {
        const value = input.value.trim();
        const fieldName = input.name;

        // Allow empty values for optional color fields
        if (!value && (fieldName === 'border_color_text' || fieldName === 'hover_shadow_color_text')) {
            this.clearFieldError(fieldName);
            return true;
        }

        if (!value) {
            this.setFieldError(fieldName, 'Colore è obbligatorio');
            return false;
        }

        if (!this.isValidColor(value)) {
            this.setFieldError(fieldName, 'Formato colore non valido (usa #RRGGBB, rgb(), rgba(), hsl(), hsla() o nomi colori CSS)');
            return false;
        }

        this.clearFieldError(fieldName);
        this.validateColorContrast();
        return true;
    }

    validateBorderWidth(width) {
        const numWidth = parseInt(width);
        
        if (isNaN(numWidth)) {
            this.setFieldError('border_width', 'Larghezza bordo deve essere un numero');
            return false;
        }

        if (numWidth < 0 || numWidth > 20) {
            this.setFieldError('border_width', 'Larghezza bordo deve essere tra 0 e 20 pixel');
            return false;
        }

        this.clearFieldError('border_width');
        return true;
    }

    validateHoverShadowIntensity(intensity) {
        const numIntensity = parseFloat(intensity);
        
        if (isNaN(numIntensity)) {
            this.setFieldError('hover_shadow_intensity', 'Intensità ombra deve essere un numero');
            return false;
        }

        if (numIntensity < 0 || numIntensity > 1) {
            this.setFieldError('hover_shadow_intensity', 'Intensità ombra deve essere tra 0 e 1');
            return false;
        }

        this.clearFieldError('hover_shadow_intensity');
        return true;
    }

    validateBackgroundGradient(gradient) {
        if (!gradient) {
            this.clearFieldError('background_gradient');
            return true; // Optional field
        }

        const gradientFunctions = ['linear-gradient', 'radial-gradient', 'conic-gradient', 'repeating-linear-gradient', 'repeating-radial-gradient'];
        const lowerGradient = gradient.toLowerCase();
        
        let isValid = false;
        for (const func of gradientFunctions) {
            if (lowerGradient.startsWith(func + '(') && gradient.endsWith(')')) {
                // Check for balanced parentheses
                const openCount = (gradient.match(/\(/g) || []).length;
                const closeCount = (gradient.match(/\)/g) || []).length;
                
                if (openCount === closeCount) {
                    // Basic content check
                    const content = gradient.substring(func.length + 1, gradient.length - 1).trim();
                    if (content.length > 0) {
                        isValid = true;
                        break;
                    }
                }
            }
        }

        if (!isValid) {
            this.setFieldError('background_gradient', 'Gradiente CSS non valido (usa linear-gradient, radial-gradient, etc.)');
            return false;
        }

        this.clearFieldError('background_gradient');
        return true;
    }

    validateColorContrast() {
        const primaryColor = document.getElementById('primary_color')?.value;
        const textColor = document.getElementById('text_color')?.value;

        if (primaryColor && textColor) {
            const contrastRatio = this.calculateContrastRatio(primaryColor, textColor);
            
            if (contrastRatio < 3.0) {
                this.setFieldError('text_color', `Contrasto insufficiente con il colore primario (${contrastRatio.toFixed(2)}:1, minimo 3:1)`);
                return false;
            }
        }

        return true;
    }

    isValidColor(color) {
        if (!color) return false;

        color = color.trim().toLowerCase();

        // Hex colors
        if (/^#([0-9a-f]{3}|[0-9a-f]{6})$/.test(color)) {
            return true;
        }

        // RGB/RGBA colors
        if (/^rgba?\(\s*\d+(\.\d+)?\s*,\s*\d+(\.\d+)?\s*,\s*\d+(\.\d+)?\s*(,\s*[0-9.]+)?\s*\)$/.test(color)) {
            return true;
        }

        // HSL/HSLA colors
        if (/^hsla?\(\s*\d+(\.\d+)?\s*,\s*\d+(\.\d+)?%\s*,\s*\d+(\.\d+)?%\s*(,\s*[0-9.]+)?\s*\)$/.test(color)) {
            return true;
        }

        // CSS named colors (basic set)
        const namedColors = [
            'black', 'white', 'red', 'green', 'blue', 'yellow', 'cyan', 'magenta',
            'gray', 'grey', 'orange', 'purple', 'pink', 'brown', 'transparent',
            'aliceblue', 'antiquewhite', 'aqua', 'aquamarine', 'azure', 'beige',
            'bisque', 'blanchedalmond', 'blueviolet', 'burlywood', 'cadetblue',
            'chartreuse', 'chocolate', 'coral', 'cornflowerblue', 'cornsilk',
            'crimson', 'darkblue', 'darkcyan', 'darkgoldenrod', 'darkgray',
            'darkgreen', 'darkkhaki', 'darkmagenta', 'darkolivegreen', 'darkorange',
            'darkorchid', 'darkred', 'darksalmon', 'darkseagreen', 'darkslateblue',
            'darkslategray', 'darkturquoise', 'darkviolet', 'deeppink', 'deepskyblue',
            'dimgray', 'dodgerblue', 'firebrick', 'floralwhite', 'forestgreen',
            'fuchsia', 'gainsboro', 'ghostwhite', 'gold', 'goldenrod', 'greenyellow',
            'honeydew', 'hotpink', 'indianred', 'indigo', 'ivory', 'khaki',
            'lavender', 'lavenderblush', 'lawngreen', 'lemonchiffon', 'lightblue',
            'lightcoral', 'lightcyan', 'lightgoldenrodyellow', 'lightgray',
            'lightgreen', 'lightpink', 'lightsalmon', 'lightseagreen', 'lightskyblue',
            'lightslategray', 'lightsteelblue', 'lightyellow', 'lime', 'limegreen',
            'linen', 'maroon', 'mediumaquamarine', 'mediumblue', 'mediumorchid',
            'mediumpurple', 'mediumseagreen', 'mediumslateblue', 'mediumspringgreen',
            'mediumturquoise', 'mediumvioletred', 'midnightblue', 'mintcream',
            'mistyrose', 'moccasin', 'navajowhite', 'navy', 'oldlace', 'olive',
            'olivedrab', 'orangered', 'orchid', 'palegoldenrod', 'palegreen',
            'paleturquoise', 'palevioletred', 'papayawhip', 'peachpuff', 'peru',
            'plum', 'powderblue', 'rosybrown', 'royalblue', 'saddlebrown', 'salmon',
            'sandybrown', 'seagreen', 'seashell', 'sienna', 'silver', 'skyblue',
            'slateblue', 'slategray', 'snow', 'springgreen', 'steelblue', 'tan',
            'teal', 'thistle', 'tomato', 'turquoise', 'violet', 'wheat', 'whitesmoke',
            'yellowgreen'
        ];

        return namedColors.includes(color);
    }

    isValidHexColor(color) {
        return /^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(color);
    }

    calculateContrastRatio(color1, color2) {
        const rgb1 = this.hexToRgb(color1);
        const rgb2 = this.hexToRgb(color2);

        if (!rgb1 || !rgb2) return 1;

        const l1 = this.getLuminance(rgb1);
        const l2 = this.getLuminance(rgb2);

        const lighter = Math.max(l1, l2);
        const darker = Math.min(l1, l2);

        return (lighter + 0.05) / (darker + 0.05);
    }

    hexToRgb(hex) {
        if (!hex || !hex.startsWith('#')) return null;

        hex = hex.substring(1);
        if (hex.length === 3) {
            hex = hex.split('').map(c => c + c).join('');
        }

        if (hex.length !== 6) return null;

        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);

        return [r, g, b];
    }

    getLuminance(rgb) {
        const [r, g, b] = rgb.map(c => {
            c = c / 255;
            return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
        });

        return 0.2126 * r + 0.7152 * g + 0.0722 * b;
    }

    autoGenerateCssClassSuffix(name) {
        const cssClassSuffixInput = document.getElementById('css_class_suffix');
        if (!cssClassSuffixInput || !cssClassSuffixInput.dataset.autoGenerated) {
            return;
        }

        const suffix = name.toLowerCase()
            .replace(/[^a-z0-9\s-]/g, '')
            .replace(/\s+/g, '-')
            .replace(/-+/g, '-')
            .replace(/^-|-$/g, '');

        cssClassSuffixInput.value = suffix;
        this.validateCssClassSuffix(suffix);
    }

    setFieldError(fieldName, message) {
        this.errors.set(fieldName, message);
        this.displayFieldError(fieldName, message);
    }

    clearFieldError(fieldName) {
        this.errors.delete(fieldName);
        this.clearFieldErrorDisplay(fieldName);
    }

    displayFieldError(fieldName, message) {
        const field = document.getElementById(fieldName) || document.querySelector(`[name="${fieldName}"]`);
        if (!field) return;

        // Remove existing error
        this.clearFieldErrorDisplay(fieldName);

        // Add error class
        field.classList.add('is-invalid');

        // Create error message element
        const errorDiv = document.createElement('div');
        errorDiv.className = 'invalid-feedback';
        errorDiv.textContent = message;
        errorDiv.id = `${fieldName}-error`;

        // Insert error message after the field
        field.parentNode.insertBefore(errorDiv, field.nextSibling);
    }

    clearFieldErrorDisplay(fieldName) {
        const field = document.getElementById(fieldName) || document.querySelector(`[name="${fieldName}"]`);
        if (!field) return;

        field.classList.remove('is-invalid');

        const errorDiv = document.getElementById(`${fieldName}-error`);
        if (errorDiv) {
            errorDiv.remove();
        }
    }

    createErrorDisplay() {
        // Create a container for validation summary if it doesn't exist
        if (!document.getElementById('validation-summary')) {
            const summaryDiv = document.createElement('div');
            summaryDiv.id = 'validation-summary';
            summaryDiv.className = 'alert alert-danger mt-3';
            summaryDiv.style.display = 'none';
            
            this.form.appendChild(summaryDiv);
        }
    }

    showValidationSummary() {
        const summaryDiv = document.getElementById('validation-summary');
        if (!summaryDiv || this.errors.size === 0) return;

        const errorList = Array.from(this.errors.entries())
            .map(([field, message]) => `<li>${message}</li>`)
            .join('');

        summaryDiv.innerHTML = `
            <h6>Errori di validazione:</h6>
            <ul class="mb-0">${errorList}</ul>
        `;
        summaryDiv.style.display = 'block';

        // Scroll to summary
        summaryDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    hideValidationSummary() {
        const summaryDiv = document.getElementById('validation-summary');
        if (summaryDiv) {
            summaryDiv.style.display = 'none';
        }
    }

    validateForm() {
        this.errors.clear();

        // Validate all fields
        const inputs = this.form.querySelectorAll('input[required], textarea[required], select[required]');
        let isValid = true;

        inputs.forEach(input => {
            if (!this.validateField(input)) {
                isValid = false;
            }
        });

        // Additional form-level validations
        if (!this.validateColorContrast()) {
            isValid = false;
        }

        if (isValid) {
            this.hideValidationSummary();
        }

        return isValid;
    }
}

// Initialize theme validator when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    if (document.getElementById('themeForm')) {
        window.themeValidator = new ThemeValidator('themeForm');
    }
});